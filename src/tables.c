/* bitbit, a bitboard based chess engine written in c.
 * Copyright (C) 2022 Isak Ellmer
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "evaluate.h"

#include <string.h>

#include "init.h"

mevalue psqtable[2][7][64];

mevalue piece_value[6] = { S( 143, 297), S( 692, 859), S( 717, 937), S( 971,1720), S(2497,3182), };

/* from white's perspective, files a to d on a regular board */
mevalue white_psqtable[6][64] = {
	{ /* pawn */
		S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0),
		S(561,670), S(476,678), S(585,634), S(516,557), S(439,597), S(195,618), S(141,712), S(128,729),
		S( 30,131), S( 56, 92), S( 64, 61), S( 66,-11), S( 79,-25), S( 22, 63), S( 26,142), S(  3,124),
		S( -1, 86), S( -2, 43), S(  0, 21), S( 17,-13), S( 15,  8), S( 52, 54), S(  8, 45), S( 17, 71),
		S( -6, 53), S(-17, 46), S( 26, 20), S( 18, 14), S( 19,  5), S( 29, 52), S(-12, 44), S(  5, 31),
		S(-23, 27), S(-27, 28), S(-11, 25), S(  4, 26), S( 17, 37), S(  3, 63), S( 37, 18), S( -2,  4),
		S(-25, 40), S( -3, 40), S( -8, 48), S(  5, 15), S(-11, 58), S( 52, 52), S( 51, 27), S(  6, 15),
		S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0), S(  0,  0),
	}, { /* knight */
		S(-149,-17), S( 63, 84), S( 18,144), S(106,123),
		S(102, 61), S( 71,100), S(123,101), S(183,132),
		S( 53, 89), S( 82, 99), S(115,139), S(137,124),
		S( 99,109), S( 36,127), S( 82,146), S( 47,155),
		S( 40,116), S( 46,108), S( 43,129), S( 44,130),
		S( -4, 59), S( 48, 52), S( 22, 54), S( 33, 98),
		S( 17, 57), S( 26, 86), S( 11, 59), S( 31, 83),
		S( 65, 41), S( 15, 43), S(  9, 61), S( 18, 81),
	}, { /* bishop */
		S( 34,176), S(-22,134), S(-111,158), S(-33,136),
		S(-25,159), S(  8,137), S( 42,128), S( 52, 92),
		S( 59,111), S( 77,145), S(127,118), S( 99,111),
		S( 28, 96), S( 65,114), S( 73,114), S( 71,144),
		S( 79, 84), S( 49, 88), S( 40,116), S( 73,135),
		S( 64, 86), S( 84, 78), S( 56,118), S( 51,121),
		S( 74, 78), S( 75, 69), S( 74, 82), S( 42, 94),
		S( -2,145), S( 49, 95), S( 16, 87), S( 53, 90),
	}, { /* rook */
		S(127,150), S( 62,177), S( 79,162), S( 56,151),
		S( 51,164), S( 28,182), S( 51,172), S( 90,158),
		S( 22,158), S( 48,159), S( 81,147), S(111,130),
		S( 10,138), S(  0,145), S( 40,123), S( 60,119),
		S(-12,101), S(-28,101), S(-28,120), S(  7, 90),
		S(-52, 57), S(-23, 63), S(-43, 81), S(-16, 68),
		S(-87, 58), S(-38, 35), S( 15, 50), S( 14, 40),
		S( 13, 38), S(-13, 57), S( 13, 55), S( 30, 48),
	}, { /* queen */
		S(-22,146), S(-19,187), S( 26,183), S(-13,182),
		S(-36,201), S(-46,206), S(-38,248), S(-42,291),
		S(  2,156), S( -2,192), S( -6,234), S( -3,231),
		S(-10,149), S( -2,212), S(-29,207), S(-12,239),
		S( 10, 92), S( -6,181), S(-15,190), S(-13,187),
		S( -9, 99), S( 36, 38), S(  3,144), S(  5, 96),
		S(  9, 14), S( 33,-27), S( 38,  1), S( 26, 56),
		S( 24,-56), S(-17, 16), S( 10,-47), S( 15, -2),
	}, { /* king */
		S(138, 48), S(113,169), S(111,174), S(105,199),
		S(-30,138), S(-156,287), S(-127,222), S(119,221),
		S(-183,199), S(-214,261), S(-205,241), S( -8,210),
		S(-179,137), S(-158,244), S(-165,213), S(-172,189),
		S(-120, 76), S(-188,165), S(-284,143), S(-110,135),
		S(-62, 14), S(-91, 79), S(-117, 79), S(-156, 86),
		S( 13,-26), S(-36, 29), S(-28, 15), S(-63, 15),
		S( 22,-138), S( 40,-65), S( -1,-74), S( 41,-129),
	}
};

mevalue pawn_shelter[28] = {
        S( 16,  6), S( 34, -5), S( 63,  8), S( 27, 36), S( -1, 67), S( 69,112), S(312,126),
        S(-43, 36), S( 18, 26), S(  0, 13), S(-32, 37), S(-55, 83), S(-29,106), S(138,153),
        S(-38, 17), S( 18, 22), S(-20, 28), S(-36, 22), S(-80, 59), S(  2, 71), S( 30,124),
        S(-65, 44), S(-14, 38), S(-34, 24), S(-41, 55), S(-47, 81), S(-152, 79), S(-159,112),
};

mevalue unblocked_storm[28] = {
        S(-25,-83), S(294,492), S( -2,323), S(-95, 93), S(-46,-19), S(-18,-62), S(-45,-44),
        S(-15,-51), S(243,492), S(-110,337), S(-48, 63), S(-25,  0), S( 23,-46), S(  6,-45),
        S( -2,-37), S(-225,141), S(-176,204), S(-50, 41), S( -8, -8), S( 17,-20), S( 11,-40),
        S(-29,-30), S(-112,340), S(-34,174), S(-45,  7), S(-13,-35), S( 15,-31), S( -7,-24),
};

mevalue blocked_storm[7] = {
        S(  0,  0), S(-45,-67), S(  2,-56), S(  5,-53), S( 16,-94), S( 23,-127), S(  4,  0),
};

mevalue mobility_bonus[4][28] = {
        {
                S(-180,-267), S(-15,-76), S( 10, 74), S( 15,135), S( 34,164), S( 45,190), S( 57,216), S( 69,224), S( 84,220),
        }, {
                S(-86,-169), S( -9, -4), S( 18, 96), S( 30,163), S( 47,193), S( 59,228), S( 64,249), S( 67,262), S( 68,276),
                S( 76,279), S( 74,282), S( 84,256), S(139,265), S(166,248),
        }, {
                S(-282,-133), S(-45,-146), S(  3, 37), S( 16, 99), S( 15,119), S( 16,138), S(  3,158), S( 15,170), S( 21,178),
                S( 37,185), S( 38,205), S( 56,201), S( 79,201), S( 78,190), S( 79,192),
        }, {
                S(  5, -9), S(-197,-93), S(-169,-278), S( 11,-87), S( 25,-17), S( 31, 69), S( 30,119), S( 26,195), S( 26,194),
                S( 26,248), S( 27,274), S( 28,289), S( 32,284), S( 41,291), S( 41,305), S( 45,304), S( 36,319), S( 34,332),
                S( 34,346), S( 45,338), S( 42,339), S( 24,365), S( 55,330), S( 77,343), S(182,284), S(247,277), S(251,288),
                S(249,313),
        }
};

void tables_init(void) {
	memset(psqtable, 0, sizeof(psqtable));
	for (int turn = 0; turn < 2; turn++) {
		for (int piece = pawn; piece <= king; piece++) {
			for (int square = 0; square < 64; square++) {
				int x = square % 8;
				int y = square / 8;
				int factor = (piece == pawn) ? 8 : 4;
				if (x >= 4 && piece != pawn)
					x = 7 - x;
				if (turn == white)
					y = 7 - y;
				psqtable[turn][piece][square] = white_psqtable[piece - 1][factor * y + x] +
					piece_value[piece - 1];
				init_status("populating evaluation lookup table");
			}
		}
	}
}
